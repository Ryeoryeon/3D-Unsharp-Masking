#version 330 core
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec4 vertexColor_diffuse;
layout(location = 2) in vec3 vertexColor_ambient;
layout(location = 3) in vec3 vertexColor_specular;
layout(location = 4) in vec3 vertexNormal_modelspace;

out vec3 Position_worldspace;
out vec3 EyeDirection_cameraspace;
out vec3 LightDirection_cameraspace;
out vec3 vertexNormal_cameraspace;

out vec3 unsharpVector;
out vec3 currentNormal_cameraspace;

uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;
uniform mat4 Transform;
uniform vec3 LightPosition_worldspace;
uniform int objNumber;

uniform isampler2D neighborNum;
uniform isampler2D neighborIdxList;
uniform sampler2D vertexNormalTex;
uniform isampler2D accumNeighborNum;
uniform sampler2D vertexPosTex;

uniform isampler2D neighborNumSecond;
uniform isampler2D neighborIdxListSecond;
uniform sampler2D vertexNormalTexSecond;
uniform isampler2D accumNeighborNumSecond;
uniform sampler2D vertexPosTexSecond;

uniform float TEXTURESIZE_FLOAT = 1024.0;
uniform float twoPi = 6.283185;
uniform float SIGMA = 0.8;

void main()
{
    gl_Position =  MVP * Transform * vec4(vertexPosition_modelspace,1);

    vec3 diffuseColor = vec3(vertexColor_diffuse);
    vec3 ModifiedAmbientColor = clamp(vertexColor_ambient, 0.1, 1.0) * diffuseColor;
    vec3 specularColor = vertexColor_specular;

    Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;
    vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;
    EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;

    vec3 LightPosition_cameraspace = (V * vec4(LightPosition_worldspace, 1)).xyz;
    LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;

    vertexNormal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz;

    // *** get 1-ring neighborhood number
    float colIdx = gl_VertexID/TEXTURESIZE_FLOAT;
    float quotient = floor(colIdx);
    float rowIdx = quotient/TEXTURESIZE_FLOAT;
    colIdx -= quotient;

    // illumination color 계산을 위한 변수들
    vec3 avgIntensity = vec3(0, 0, 0);
    vec3 LightColor = vec3(1,1,1);
    float LightPower = 30.0f;

    vec3 l = normalize(LightDirection_cameraspace);
    vec3 E = normalize(EyeDirection_cameraspace);
    float distance = length( LightPosition_worldspace - Position_worldspace );

    // *** 현재 vertex의 illumination color 계산

    //vec3 currentNormal = texture(vertexNormalTex, vec2(colIdx, rowIdx)).rgb;
    //currentNormal_cameraspace = ( V * M * vec4(currentNormal, 0)).xyz;

    vec3 currentNormal_cameraspace = ( V * M * vec4(vertexNormal_modelspace, 0)).xyz;
    vec3 n = normalize(currentNormal_cameraspace);
    vec3 R = reflect (-l, n);
    float cosAlpha = clamp( dot( E,R ), 0,1 );
    float cosTheta = clamp( dot( n,l), 0,1 );

    vec3 currentColor = ModifiedAmbientColor + diffuseColor * LightColor * LightPower * cosTheta / (distance*distance) + specularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);

    float currentIntensity = (currentColor.x + currentColor.y + currentColor.z) / 3.0f;
    // 시그마 1 가우시안 계수
    float GAUSSIAN = 1.0/sqrt(twoPi * SIGMA * SIGMA);   
    // 계수 누적
    float accumCoefficient = 0;

    int currentNeighborNum;
    int startVertexIdx;
    int endVertexIdx;

    if(objNumber == 1)
    {
        currentNeighborNum = texture(neighborNum, vec2(colIdx, rowIdx)).r;
        startVertexIdx = texture(accumNeighborNum, vec2(colIdx, rowIdx)).r;
        endVertexIdx = startVertexIdx + currentNeighborNum;
    }

    if(objNumber == 2)
    {
        currentNeighborNum = texture(neighborNumSecond, vec2(colIdx, rowIdx)).r;
        startVertexIdx = texture(accumNeighborNumSecond, vec2(colIdx, rowIdx)).r;
        endVertexIdx = startVertexIdx + currentNeighborNum;
    }

    for (int i = startVertexIdx; i < endVertexIdx; i++)
    {
        unsharpVector = vec3(1, 1, 1);
        // 현재 vertex의 이웃에 순차적으로 접근
        float i_float = float(i);
        float neighborColIdx = i_float/TEXTURESIZE_FLOAT;
        float neighborQuotient = floor(neighborColIdx);
        float neighborRowIdx = neighborQuotient/TEXTURESIZE_FLOAT;

        // 이웃의 정보 가져오기
        vec3 neighborNormal;
        vec3 neighborPos;

        if(objNumber == 1)
        {
            float currentNeighborIdx = texture(neighborIdxList, vec2(neighborColIdx, neighborRowIdx)).r;
            float neighborInforColIdx = currentNeighborIdx/TEXTURESIZE_FLOAT;
            float neighborInforQuotient = floor(neighborInforColIdx);
            float neighborInforRowIdx = neighborInforQuotient/TEXTURESIZE_FLOAT;
            neighborInforColIdx -= neighborInforQuotient;
            neighborNormal = texture(vertexNormalTex, vec2(neighborInforColIdx, neighborInforRowIdx)).rgb;
            neighborPos = texture(vertexPosTex, vec2(neighborInforColIdx, neighborInforRowIdx)).rgb;
        }

        if(objNumber == 2)
        {
            float currentNeighborIdx = texture(neighborIdxListSecond, vec2(neighborColIdx, neighborRowIdx)).r;
            float neighborInforColIdx = currentNeighborIdx/TEXTURESIZE_FLOAT;
            float neighborInforQuotient = floor(neighborInforColIdx);
            float neighborInforRowIdx = neighborInforQuotient/TEXTURESIZE_FLOAT;
            neighborInforColIdx -= neighborInforQuotient;
            neighborNormal = texture(vertexNormalTexSecond, vec2(neighborInforColIdx, neighborInforRowIdx)).rgb;
            neighborPos = texture(vertexPosTexSecond, vec2(neighborInforColIdx, neighborInforRowIdx)).rgb;
        }
        vec3 neighborPos_cameraspace = ( V * M * vec4(neighborPos,1)).xyz;

        // *** 이웃들의 illumination color 계산
        vec3 neighborNormal_cameraspace = ( V * M * vec4(neighborNormal,0)).xyz;
        vec3 n = normalize(neighborNormal_cameraspace);
        vec3 R = reflect (-l, n);
        float cosAlpha = clamp( dot( E,R ), 0,1 );
        float cosTheta = clamp( dot( n,l), 0,1 );

        vec3 neighborColor = ModifiedAmbientColor + diffuseColor * LightColor * LightPower * cosTheta / (distance*distance) + specularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);

        float neighborIntensity = (neighborColor.x + neighborColor.y + neighborColor.z) / 3.0f;

        // *** bilateral filtering

        // 밝기의 차
        float intensitySub = currentIntensity - neighborIntensity;
        float intensityGaussian = GAUSSIAN * exp(-((intensitySub * intensitySub)/(2.0f * SIGMA * SIGMA)));

        // 거리의 차
        vec3 positionSub = vertexPosition_cameraspace - neighborPos_cameraspace;
        float positionGaussian = GAUSSIAN * exp(-((positionSub.x * positionSub.x)/(2.0f * SIGMA * SIGMA)));
        positionGaussian *= GAUSSIAN * exp(-((positionSub.y * positionSub.y)/(2.0f * SIGMA * SIGMA)));
        positionGaussian *= GAUSSIAN * exp(-((positionSub.z * positionSub.z)/(2.0f * SIGMA * SIGMA)));

        avgIntensity += intensityGaussian * positionGaussian * neighborColor;
        accumCoefficient += intensityGaussian * positionGaussian;
    }

    float neighborNum_float = float(currentNeighborNum);
    avgIntensity /= accumCoefficient;
    //avgIntensity /= neighborNum_float;

    // *** 평균과의 차 구하고, 내보내기
    unsharpVector = currentColor - avgIntensity;
    unsharpVector += currentColor;
    //unsharpVector = currentColor; // 원래 color 내보내기
}
